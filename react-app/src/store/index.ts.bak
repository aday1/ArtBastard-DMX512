export * from './store';

// Types and interfaces
export interface MidiMapping {
  channel: number;
  note?: number;
  controller?: number;
}

export interface Fixture {
  id: string;
  name: string;
  type: string;
  manufacturer?: string;
  model?: string;
  mode?: string;
  startAddress: number;
  channels: { name: string; type: string; dmxAddress?: number }[];
  notes?: string; // Notes section for fixture documentation
  // Flagging system for organizing fixtures
  flags?: FixtureFlag[];
  isFlagged?: boolean;
}

export interface FixtureFlag {
  id: string;
  name: string;
  color: string;
  priority?: number; // Higher numbers = higher priority
  category?: string; // Optional grouping
}

export interface Group {
  id: string;
  name: string;
  fixtureIndices: number[];
  // New fields for enhanced functionality
  lastStates: number[]; // Last known DMX values for each fixture in the group
  position?: { x: number; y: number }; // Position on 2D canvas
  isMuted: boolean;
  isSolo: boolean;
  masterValue: number; // Current master value (0-255)
  midiMapping?: MidiMapping;
  oscAddress?: string;
  ignoreSceneChanges?: boolean; // Whether this group ignores scene changes
  ignoreMasterFader?: boolean;
  panOffset?: number;
  tiltOffset?: number;
  zoomValue?: number;
}

export interface Scene {
  name: string
  channelValues: number[]
  oscAddress: string
  midiMapping?: MidiMapping
}

export interface ArtNetConfig {
  ip: string
  subnet: number
  universe: number
  net: number
  port: number
  base_refresh_interval: number
}

export interface OscConfig {
  host: string
  port: number
  sendEnabled: boolean
  sendHost: string
  sendPort: number
}

export interface OscActivity {
  value: number // Float value 0.0 to 1.0
  timestamp: number // Timestamp of the last message
}

// Define OscMessage interface
export interface OscMessage {
  address: string;
  args: Array<{ type: string; value: any }>;

  // Optional: if source information is available
  source?: string; 
  // Optional: for ordering or display
  timestamp?: number; 
}

// Define PlacedFixture type for 2D canvas layout
export interface PlacedFixture {
  id: string; 
  fixtureId: string;
  fixtureStoreId: string; 
  name: string; 
  x: number;
  y: number;
  color: string;
  radius: number;
  startAddress: number; // DMX start address for this fixture
  controls?: PlacedControl[]; // Optional array for controls associated with this fixture
}

// Definition for PlacedControl on the 2D canvas, associated with a PlacedFixture
export interface PlacedControl {
  id: string;                     // Unique ID for this control instance
  channelNameInFixture: string; // Name of the channel within the fixture's definition (e.g., "Dimmer", "Pan")
  type: 'slider' | 'xypad';       // Control type: slider for single channel, xypad for pan/tilt combined
  label: string;                  // Display label for the control (e.g., could be same as channelNameInFixture or custom)
  xOffset: number;                // X position relative to the fixture icon's center
  yOffset: number;                // Y position relative to the fixture icon's center
  currentValue: number;           // Current value of this control (0-255), for sliders only
  // XY Pad specific fields
  panValue?: number;              // Pan value (0-255) for xypad controls
  tiltValue?: number;             // Tilt value (0-255) for xypad controls
  panChannelName?: string;        // Name of the pan channel (e.g., "Pan")
  tiltChannelName?: string;       // Name of the tilt channel (e.g., "Tilt")
}

// Define MasterSlider related types
export interface MasterSliderTarget {
  placedFixtureId: string;        // ID of the PlacedFixture instance on the canvas
  channelIndex: number;           // Index of the channel within that fixture's definition (0-based)
  channelNameInFixture: string;   // Name of the channel (e.g., "Dimmer", "Pan") for display and easier association
  minRange: number;               // Min value for the target channel (e.g., 0)
  maxRange: number;               // Max value for the target channel (e.g., 255)
}

export interface MasterSlider {
  id: string;
  name: string;
  value: number; // Current value (0-255, or 0-1, let's use 0-255 for consistency with DMX)
  targets: MasterSliderTarget[];
  position: { x: number; y: number }; // Position on the 2D canvas
  midiMapping?: MidiMapping; // Re-use existing MidiMapping type
}

// Timeline Sequence Management
export interface TimelineKeyframe {
  time: number; // milliseconds from start
  value: number; // 0-255
  curve: 'linear' | 'smooth' | 'step' | 'ease-in' | 'ease-out' | 'ease-in-out' | 'bezier';
  // For bezier curves
  controlPoint1?: { x: number; y: number };
  controlPoint2?: { x: number; y: number };
}

export interface TimelineSequence {
  id: string;
  name: string;
  description?: string;
  duration: number; // Total duration in milliseconds
  channels: Array<{
    channel: number;
    keyframes: TimelineKeyframe[];
  }>;
  tags?: string[];
  createdAt: number;
  modifiedAt: number;
}

export interface TimelinePreset {
  id: string;
  name: string;
  description: string;
  generator: (duration: number, amplitude?: number, frequency?: number, phase?: number) => TimelineKeyframe[];
}

// Notification type definition (used in State and actions)
export interface Notification {
  id: string;
  message: string;
  type: 'success' | 'error' | 'info' | 'warning';
  priority?: 'low' | 'normal' | 'high';
  persistent?: boolean;
  dismissible?: boolean;
  timestamp: number;
}

// Input type for addNotification action
export type AddNotificationInput = Omit<Notification, 'id' | 'timestamp'>;

// Type for batch DMX channel updates
export type DmxChannelBatchUpdate = Record<number, number>;

// Auto-Scene settings interface for localStorage persistence
interface AutoSceneSettings {
  autoSceneEnabled: boolean;
  autoSceneList: string[];
  autoSceneMode: 'forward' | 'ping-pong' | 'random';
  autoSceneBeatDivision: number;
  autoSceneManualBpm: number;
  autoSceneTapTempoBpm: number;
  autoSceneTempoSource: 'internal_clock' | 'manual_bpm' | 'tap_tempo';
}

// Helper functions for localStorage persistence
const AUTO_SCENE_STORAGE_KEY = 'artbastard-auto-scene-settings';

const saveAutoSceneSettings = (settings: AutoSceneSettings) => {
  try {
    localStorage.setItem(AUTO_SCENE_STORAGE_KEY, JSON.stringify(settings));
  } catch (error) {
    console.warn('Failed to save auto-scene settings to localStorage:', error);
  }
};

const loadAutoSceneSettings = (): Partial<AutoSceneSettings> => {
  try {
    const stored = localStorage.getItem(AUTO_SCENE_STORAGE_KEY);
    return stored ? JSON.parse(stored) : {};
  } catch (error) {
    console.warn('Failed to load auto-scene settings from localStorage:', error);
    return {};
  }
};

// Helper to save current auto-scene settings from store state
const saveCurrentAutoSceneSettings = (state: any) => {
  const settings: AutoSceneSettings = {
    autoSceneEnabled: state.autoSceneEnabled,
    autoSceneList: state.autoSceneList,
    autoSceneMode: state.autoSceneMode,
    autoSceneBeatDivision: state.autoSceneBeatDivision,
    autoSceneManualBpm: state.autoSceneManualBpm,
    autoSceneTapTempoBpm: state.autoSceneTapTempoBpm,
    autoSceneTempoSource: state.autoSceneTempoSource,
  };
  saveAutoSceneSettings(settings);
};

interface State {
  // DMX State
  dmxChannels: number[]
  oscAssignments: string[]
  channelNames: string[]
  selectedChannels: number[]
  
  // Navigation State
  navVisibility: {
    main: boolean
    midiOsc: boolean
    fixture: boolean
    scenes: boolean
    audio: boolean
    touchosc: boolean
    misc: boolean
  }

  // Debug State
  debugTools: {
    debugButton: boolean
    midiMonitor: boolean
    oscMonitor: boolean
  }
  // MIDI State
  midiInterfaces: string[]
  activeInterfaces: string[]
  midiMappings: Record<number, MidiMapping | undefined> 
  midiLearnTarget: 
    | { type: 'masterSlider'; id: string }
    | { type: 'dmxChannel'; channelIndex: number }
    | { type: 'placedControl'; fixtureId: string; controlId: string }
    | { type: 'group'; groupId: string }
    | null;
  midiLearnScene: string | null 
  midiMessages: any[]
  oscMessages: OscMessage[]; // Added for OSC Monitor
  midiActivity: number // Activity level for MIDI signal flash indicator

  // Audio/BPM State
  bpm: number // Current BPM value
  isPlaying: boolean // Whether audio/MIDI is currently playing

  // Debug State
  debugModules: {
    midi: boolean;
    osc: boolean;
    artnet: boolean;
    button: boolean;
  };

  // Fixtures and Groups
  fixtures: Fixture[]
  groups: Group[]
  
  // Scenes
  scenes: Scene[]
    // ArtNet
  artNetConfig: ArtNetConfig
  oscConfig: OscConfig
  artNetStatus: 'connected' | 'disconnected' | 'error' | 'timeout'  // UI State
  theme: 'artsnob' | 'standard' | 'minimal';
  darkMode: boolean;
  // statusMessage: { text: string; type: 'success' | 'error' | 'info' | 'warning' } | null; // Deprecated
  notifications: Notification[]; // Use the new Notification interface
  
  // UI Settings
  uiSettings: {
    sparklesEnabled: boolean;
  };
  
  oscActivity: Record<number, OscActivity>
  exampleSliderValue: number;
  fixtureLayout: PlacedFixture[]; 
  placedFixtures: PlacedFixture[]; 
  masterSliders: MasterSlider[]; 
  canvasBackgroundImage: HTMLImageElement | null; 

  // Scene Transition State
  isTransitioning: boolean;
  transitionStartTime: number | null;
  transitionDuration: number; // in ms
  fromDmxValues: number[] | null;
  toDmxValues: number[] | null;
  currentTransitionFrame: number | null; // requestAnimationFrame ID      // Socket state
      socket: Socket | null
      setSocket: (socket: Socket | null) => void

      // Timeline Sequence Management Actions
      loadTimelineSequence: (sequenceId: string) => void
      deleteTimelineSequence: (sequenceId: string) => void
      updateTimelineSequence: (sequenceId: string, updates: Partial<TimelineSequence>) => void
      exportTimelineSequence: (sequenceId: string) => void
      importTimelineSequence: (file: File) => void
      smoothTimelineSequence: (sequenceId: string, smoothingFactor?: number) => void
      playTimelineSequence: (sequenceId: string) => void
      stopTimelinePlayback: () => void
      generateTimelinePresets: () => void
      createTimelineFromPreset: (presetId: string, name: string, channels: number[], config: {
        duration: number;
        amplitude?: number;
        frequency?: number;
        phase?: number;
      }) => string | null

  // MIDI Clock Sync State
  availableMidiClockHosts: Array<{ id: string; name: string }>;
  selectedMidiClockHostId: string | null;
  midiClockBpm: number;
  midiClockIsPlaying: boolean;
  midiClockCurrentBeat: number;
  midiClockCurrentBar: number;
  // Auto-Scene Feature State
  autoSceneEnabled: boolean;
  autoSceneList: string[]; // Names of scenes selected for auto-sequencing
  autoSceneMode: 'forward' | 'ping-pong' | 'random';
  autoSceneCurrentIndex: number;
  autoScenePingPongDirection: 'forward' | 'backward';
  autoSceneBeatDivision: number; // e.g., 4 for every 4 beats (1 bar in 4/4)
  autoSceneManualBpm: number;
  autoSceneTapTempoBpm: number;
  autoSceneLastTapTime: number; // For tap tempo calculation
  autoSceneTapTimes: number[]; // Stores recent tap intervals
  autoSceneTempoSource: 'internal_clock' | 'manual_bpm' | 'tap_tempo';
  autoSceneIsFlashing: boolean; // Shared flashing state for downbeat border flash

  // Autopilot Track System State
  autopilotTrackEnabled: boolean;
  autopilotTrackType: 'circle' | 'figure8' | 'square' | 'triangle' | 'linear' | 'random' | 'custom';
  autopilotTrackPosition: number; // 0-100, position along the track
  autopilotTrackSize: number; // 0-100, size/scale of the track
  autopilotTrackSpeed: number; // 0-100, speed of automatic movement (when auto-playing)
  autopilotTrackCenterX: number; // 0-255, center point X for the track
  autopilotTrackCenterY: number; // 0-255, center point Y for the track
  autopilotTrackAutoPlay: boolean; // Auto-advance along track  autopilotTrackCustomPoints: Array<{ x: number; y: number }>; // Custom track points

  // Recording and Automation System State
  recordingActive: boolean;
  recordingStartTime: number | null;
  recordingData: Array<{
    timestamp: number;
    type: 'dmx' | 'midi' | 'osc';
    channel?: number;
    value?: number;
    data?: any;
  }>;
  automationTracks: Array<{
    id: string;
    name: string;
    channel: number;
    keyframes: Array<{
      time: number; // milliseconds from start
      value: number; // 0-255
      curve: 'linear' | 'smooth' | 'step' | 'ease-in' | 'ease-out' | 'ease-in-out';
    }>;
    enabled: boolean;
    loop: boolean;
  }>;  automationPlayback: {
    active: boolean;
    startTime: number | null;
    duration: number; // Total duration in milliseconds
    position: number; // Current position 0-1
    mode: 'forward' | 'reverse' | 'ping-pong' | 'loop';
    direction: 'forward' | 'reverse'; // Current direction for ping-pong mode
    loop: boolean; // Whether to loop the entire timeline
    speed: number; // Playback speed multiplier (1.0 = normal, 0.5 = half speed, 2.0 = double speed)
  };
  // Smooth DMX Output System
  smoothDmxEnabled: boolean;
  smoothDmxUpdateRate: number; // Updates per second (default: 30fps)
  smoothDmxThreshold: number; // Minimum change to trigger update (default: 1)
  pendingSmoothUpdates: { [channel: number]: number }; // Pending smooth updates
  lastSmoothUpdateTime: number;

  // Timeline Sequence Management
  timelineSequences: TimelineSequence[];
  activeTimelineSequence: string | null; // Currently loaded/selected sequence
  timelineEditMode: boolean;
  timelinePresets: TimelinePreset[];
  timelinePlayback: {
    active: boolean;
    sequenceId: string | null;
    startTime: number | null;
    position: number; // 0-1
    loop: boolean;
  };

  // Actions
  fetchInitialState: () => Promise<void>
  getDmxChannelValue: (channel: number) => number
  setDmxChannel: (channel: number, value: number) => void
  setMultipleDmxChannels: (updates: DmxChannelBatchUpdate) => void; // New action for batch updates
  setDmxChannelValue: (channel: number, value: number) => void
  setDmxChannelsForTransition: (values: number[]) => void; 
  setCurrentTransitionFrameId: (frameId: number | null) => void; 
  clearTransitionState: () => void; 
  setTransitionDuration: (duration: number) => void; 
  selectChannel: (channel: number) => void
  deselectChannel: (channel: number) => void
  toggleChannelSelection: (channel: number) => void
  selectAllChannels: () => void
  deselectAllChannels: () => void
  invertChannelSelection: () => void
  setOscAssignment: (channelIndex: number, address: string) => void
  reportOscActivity: (channelIndex: number, value: number) => void 
  addOscMessage: (message: OscMessage) => void; // Added for OSC Monitor
    // MIDI Actions
  startMidiLearn: (target: { type: 'masterSlider', id: string } | { type: 'dmxChannel', channelIndex: number } | { type: 'group', id: string }) => void;
  cancelMidiLearn: () => void
  addMidiMessage: (message: any) => void
  addMidiMapping: (dmxChannel: number, mapping: MidiMapping) => void 
  removeMidiMapping: (dmxChannel: number) => void
  clearAllMidiMappings: () => void
  
  // Scene Actions
  saveScene: (name: string, oscAddress: string) => void
  loadScene: (name: string) => void
  deleteScene: (name: string) => void
  updateScene: (originalName: string, updates: Partial<Scene>) => void; // New action for updating scenes
    // Config Actions
  updateArtNetConfig: (config: Partial<ArtNetConfig>) => void
  updateDebugModules: (debugSettings: {midi?: boolean; osc?: boolean; artnet?: boolean; button?: boolean}) => void
  testArtNetConnection: () => void    // UI Actions
  setTheme: (theme: 'artsnob' | 'standard' | 'minimal') => void;
  toggleDarkMode: () => void;
  
  // UI Settings Actions
  updateUiSettings: (settings: Partial<{ sparklesEnabled: boolean }>) => void;
  toggleSparkles: () => void;
  
  // showStatusMessage: (text: string, type: 'success' | 'error' | 'info' | 'warning') => void; // Deprecated
  // clearStatusMessage: () => void; // Deprecated
  addNotification: (notification: AddNotificationInput) => void; // Use AddNotificationInput
  removeNotification: (id: string) => void;
  clearAllNotifications: () => void;
  setExampleSliderValue: (value: number) => void;
  setBpm: (bpm: number) => void;
  setIsPlaying: (isPlaying: boolean) => void;
  setMidiActivity: (activity: number) => void;
  setFixtureLayout: (layout: PlacedFixture[]) => void 
  setCanvasBackgroundImage: (image: HTMLImageElement | null) => void 
  addMasterSlider: (slider: MasterSlider) => void;
  updateMasterSliderValue: (sliderId: string, value: number) => void;
  updateMasterSlider: (sliderId: string, updatedSlider: Partial<MasterSlider>) => void; 
  removeMasterSlider: (sliderId: string) => void;
  setMasterSliders: (sliders: MasterSlider[]) => void;
  setSelectedMidiClockHostId: (hostId: string | null) => void; // Will be called by WS handler too
  setAvailableMidiClockHosts: (hosts: Array<{ id: string; name: string }>) => void; // Called by WS handler
  setMidiClockBpm: (bpm: number) => void; // Called by WS handler, and also repurposed for user requests
  setMidiClockIsPlaying: (isPlaying: boolean) => void; // Called by WS handler
  setMidiClockBeatBar: (beat: number, bar: number) => void; // Called by WS handler
  requestToggleMasterClockPlayPause: () => void; // Renamed action
  // Auto-Scene Actions
  setAutoSceneEnabled: (enabled: boolean) => void;
  setAutoSceneList: (sceneNames: string[]) => void;
  setAutoSceneMode: (mode: 'forward' | 'ping-pong' | 'random') => void;  setAutoSceneBeatDivision: (division: number) => void;
  setAutoSceneTempoSource: (source: 'internal_clock' | 'manual_bpm' | 'tap_tempo') => void;
  setNextAutoSceneIndex: () => void; // Calculates and updates autoSceneCurrentIndex
  resetAutoSceneIndex: () => void;
  setManualBpm: (bpm: number) => void; // For auto-scene manual tempo
  recordTapTempo: () => void;         // For auto-scene tap tempo
  triggerAutoSceneFlash: () => void;  // Triggers the shared flashing state

  // Group Actions
  updateGroup: (groupId: string, groupData: Partial<Group>) => void;
  saveGroupLastStates: (groupId: string) => void;
  setGroupMasterValue: (groupId: string, value: number) => void;
  setGroupMute: (groupId: string, muted: boolean) => void;
  setGroupSolo: (groupId: string, solo: boolean) => void;
  setGroupPanOffset: (groupId: string, offset: number) => void;
  setGroupTiltOffset: (groupId: string, offset: number) => void;
  setGroupZoomValue: (groupId: string, value: number) => void;
  startGroupMidiLearn: (groupId: string) => void;
  setGroupMidiMapping: (groupId: string, mapping?: MidiMapping) => void;

  // Fixture Flagging Actions
  addFixtureFlag: (fixtureId: string, flag: FixtureFlag) => void;
  removeFixtureFlag: (fixtureId: string, flagId: string) => void;
  toggleFixtureFlag: (fixtureId: string, flagId: string) => void;
  updateFixtureFlag: (fixtureId: string, flagId: string, updates: Partial<FixtureFlag>) => void;
  clearFixtureFlags: (fixtureId: string) => void;
  getFixturesByFlag: (flagId: string) => Fixture[];
  getFixturesByFlagCategory: (category: string) => Fixture[];
  createQuickFlag: (name: string, color: string, category: string) => FixtureFlag;
  bulkAddFlag: (fixtureIds: string[], flag: FixtureFlag) => void;
  bulkRemoveFlag: (fixtureIds: string[], flagId: string) => void;

  // Autopilot Track Actions
  setAutopilotTrackEnabled: (enabled: boolean) => void;
  setAutopilotTrackType: (type: 'circle' | 'figure8' | 'square' | 'triangle' | 'linear' | 'random' | 'custom') => void;
  setAutopilotTrackPosition: (position: number) => void;
  setAutopilotTrackSize: (size: number) => void;
  setAutopilotTrackSpeed: (speed: number) => void;
  setAutopilotTrackCenter: (centerX: number, centerY: number) => void;
  setAutopilotTrackAutoPlay: (autoPlay: boolean) => void;
  setAutopilotTrackCustomPoints: (points: Array<{ x: number; y: number }>) => void;  calculateTrackPosition: (trackType: string, position: number, size: number, centerX: number, centerY: number) => { pan: number; tilt: number };
  updatePanTiltFromTrack: () => void;

  // Recording and Automation Actions
  startRecording: () => void;
  stopRecording: () => void;
  clearRecording: () => void;
  addRecordingEvent: (event: { type: 'dmx' | 'midi' | 'osc'; channel?: number; value?: number; data?: any }) => void;
  createAutomationTrack: (name: string, channel: number) => string; // Returns track ID
  updateAutomationTrack: (trackId: string, updates: Partial<{ name: string; enabled: boolean; loop: boolean }>) => void;
  deleteAutomationTrack: (trackId: string) => void;  addKeyframe: (trackId: string, time: number, value: number, curve?: 'linear' | 'smooth' | 'step' | 'ease-in' | 'ease-out' | 'ease-in-out') => void;
  updateKeyframe: (trackId: string, keyframeIndex: number, updates: Partial<{ time: number; value: number; curve: string }>) => void;
  deleteKeyframe: (trackId: string, keyframeIndex: number) => void;
  startAutomationPlayback: () => void;
  stopAutomationPlayback: () => void;
  setAutomationPosition: (position: number) => void; // 0-1
  applyAutomationPreset: (trackId: string, preset: 'sine' | 'triangle' | 'sawtooth' | 'square' | 'random') => void;
  // Advanced Playback Mode Actions
  setAutomationPlaybackMode: (mode: 'forward' | 'reverse' | 'ping-pong' | 'loop') => void;
  setAutomationLoop: (loop: boolean) => void;
  setAutomationSpeed: (speed: number) => void;
  reverseAutomationDirection: () => void;
  playRecordingTimeline: () => void;

  // Timeline Sequence Management Actions
  loadTimelineSequence: (sequenceId: string) => {
    const timelineSequences = get().timelineSequences;
    const sequence = timelineSequences.find(s => s.id === sequenceId);
    if (!sequence) {
      console.warn(`Timeline sequence ${sequenceId} not found`);
      return;
    }

    set({
      activeTimelineSequence: sequenceId,
      timelinePlayback: {
        ...get().timelinePlayback,
        sequenceId,
        position: 0,
        startTime: null,        active: false,
      }
}

// Helper function for timeline value interpolation
function interpolateChannelValue(keyframes: TimelineKeyframe[], time: number): number | undefined {
  if (keyframes.length === 0) return undefined;
  if (keyframes.length === 1) return keyframes[0].value;

  // Find the keyframes before and after the current time
  let prevFrame = keyframes[0];
  let nextFrame = keyframes[keyframes.length - 1];

  for (let i = 0; i < keyframes.length - 1; i++) {
    if (keyframes[i].time <= time && keyframes[i + 1].time > time) {
      prevFrame = keyframes[i];
      nextFrame = keyframes[i + 1];
      break;
    }
  }

  if (prevFrame === nextFrame) {
    return prevFrame.value;
  }

  const progress = (time - prevFrame.time) / (nextFrame.time - prevFrame.time);

  switch (prevFrame.curve) {
    case 'step':
      return prevFrame.value;
    
    case 'linear':
      return prevFrame.value + (nextFrame.value - prevFrame.value) * progress;
    
    case 'smooth':
      // Use smoothstep interpolation
      const t = progress * progress * (3 - 2 * progress);
      return prevFrame.value + (nextFrame.value - prevFrame.value) * t;
    
    case 'ease-in':
      const ti = progress * progress;
      return prevFrame.value + (nextFrame.value - prevFrame.value) * ti;
    
    case 'ease-out':
      const to = 1 - Math.pow(1 - progress, 2);
      return prevFrame.value + (nextFrame.value - prevFrame.value) * to;
    
    case 'ease-in-out':
      const tio = progress < 0.5
        ? 2 * progress * progress
        : 1 - Math.pow(-2 * progress + 2, 2) / 2;
      return prevFrame.value + (nextFrame.value - prevFrame.value) * tio;
    
    case 'bezier':
      if (prevFrame.controlPoint1 && prevFrame.controlPoint2) {
        // Cubic Bezier interpolation
        const t = progress;
        const u = 1 - t;
        const tt = t * t;
        const uu = u * u;
        const uuu = uu * u;
        const ttt = tt * t;
        
        const p0 = prevFrame.value;
        const p1 = prevFrame.controlPoint1.y;
        const p2 = prevFrame.controlPoint2.y;
        const p3 = nextFrame.value;
        
        return uuu * p0 + 3 * uu * t * p1 + 3 * u * tt * p2 + ttt * p3;
      }
      return prevFrame.value + (nextFrame.value - prevFrame.value) * progress;
    
    default:
      return prevFrame.value + (nextFrame.value - prevFrame.value) * progress;
  }
}

export const useStore = create(
  devtools(
    (set, get): State => ({
      // Timeline Management State
      timelineSequences: [
        {
          id: 'example-moving-light' as string,
          name: 'Example: Moving Head Pan/Tilt' as string,
          description: 'A figure-8 pattern with smooth dimming' as string,
          duration: 10000, // 10 seconds
          channels: [
            {
              channel: 1, // Pan
              keyframes: [
                { time: 0, value: 0, curve: 'smooth' as const },
                { time: 2500, value: 255, curve: 'smooth' as const },
                { time: 5000, value: 0, curve: 'smooth' as const },
                { time: 7500, value: 255, curve: 'smooth' as const },
                { time: 10000, value: 0, curve: 'smooth' as const }
              ]
            },
            {
              channel: 2, // Tilt
              keyframes: [
                { time: 0, value: 127, curve: 'smooth' as const },
                { time: 2500, value: 255, curve: 'smooth' as const },
                { time: 5000, value: 127, curve: 'smooth' as const },
                { time: 7500, value: 0, curve: 'smooth' as const },
                { time: 10000, value: 127, curve: 'smooth' as const }
              ]
            },
            {
              channel: 3, // Dimmer
              keyframes: [
                { time: 0, value: 255, curve: 'smooth' as const },
                { time: 5000, value: 127, curve: 'smooth' as const },
                { time: 10000, value: 255, curve: 'smooth' as const }
              ]
            }
          ],
          tags: ['example', 'moving-head', 'pan-tilt'] as string[],
          createdAt: Date.now(),
          modifiedAt: Date.now()
        } as TimelineSequence,
        // Blank timeline template
        {
          id: 'blank-template' as string,
          name: 'Blank Timeline' as string,
          description: 'A blank timeline ready for your creativity' as string,
          duration: 5000, // 5 seconds
          channels: [] as Array<{
            channel: number;
            keyframes: Array<{ time: number; value: number; curve: 'smooth' | 'linear' | 'step' }>;
          }>,
          tags: ['template'] as string[],
          createdAt: Date.now(),
          modifiedAt: Date.now()
        } as TimelineSequence
      ] as TimelineSequence[],
      activeTimelineSequence: null as string | null,
      timelineEditMode: false,
      timelinePresets: [] as TimelinePreset[],
      timelinePlayback: {
        active: false,
        sequenceId: null as string | null,
        startTime: null as number | null,
        position: 0,
        loop: false,
      },
                { time: 10000, value: 0, curve: 'smooth' }
              ]
            },
            {
              channel: 2, // Tilt
              keyframes: [
                { time: 0, value: 127, curve: 'smooth' },
                { time: 2500, value: 255, curve: 'smooth' },
                { time: 5000, value: 127, curve: 'smooth' },
                { time: 7500, value: 0, curve: 'smooth' },
                { time: 10000, value: 127, curve: 'smooth' }
              ]
            },
            {
              channel: 3, // Dimmer
              keyframes: [
                { time: 0, value: 255, curve: 'smooth' },
                { time: 5000, value: 127, curve: 'smooth' },
                { time: 10000, value: 255, curve: 'smooth' }
              ]
            }
          ],
          tags: ['example', 'moving-head', 'pan-tilt'],
          createdAt: Date.now(),
          modifiedAt: Date.now()
        },
        // Blank timeline template
        {
          id: 'blank-template',
          name: 'Blank Timeline',
          description: 'A blank timeline ready for your creativity',
          duration: 5000, // 5 seconds
          channels: [],
          tags: ['template'],
          createdAt: Date.now(),
          modifiedAt: Date.now()
        }
      ],
      activeTimelineSequence: null,
      timelineEditMode: false,
      timelinePresets: [],
      timelinePlayback: {
        active: false,
        sequenceId: null,
        startTime: null,
        position: 0,
        loop: false,
      },
      dmxChannels: new Array(512).fill(0),
      oscAssignments: new Array(512).fill(""),
      channelNames: new Array(512).fill(""),
      selectedChannels: [],
      isReady: false,
      midiInterfaces: [],
      activeInterfaces: [],
      midiMappings: {},
      midiLearnTarget: null,
      midiLearnScene: null,
      midiMessages: [],
      midiActivity: 0,
      oscMessages: [],
      debugTools: {
        debugButton: false,
        midiMonitor: false,
        oscMonitor: false
      },
      fixtures: [],
      groups: [],
      scenes: [],
      artNetConfig: {
        ip: '127.0.0.1',
        subnet: 0,
        universe: 0,
        net: 0,
        port: 6454,
        base_refresh_interval: 1000/30
      },
      oscConfig: {
        host: '127.0.0.1',
        port: 8000,
        sendEnabled: false,
        sendHost: '127.0.0.1',
        sendPort: 9000
      },
      artNetStatus: 'disconnected',
      theme: 'artsnob',
      darkMode: true,
      uiSettings: {
        sparklesEnabled: true
      },
      notifications: [],
      bpm: 120,
      isPlaying: false,
      debugModules: {
        midi: false,
        osc: false,
        artnet: false,
        button: false
      },
      oscActivity: {},
      exampleSliderValue: 0,
      fixtureLayout: [],
      placedFixtures: [],
      masterSliders: [],
      canvasBackgroundImage: null,
      socket: null,

      // Timeline Management Actions
      loadTimelineSequence: (sequenceId) => {
        const timelineSequences = get().timelineSequences;
        const sequence = timelineSequences.find(s => s.id === sequenceId);
        if (!sequence) {
          console.warn(`Timeline sequence ${sequenceId} not found`);
          return;
        }

        set({
          activeTimelineSequence: sequenceId,
          timelinePlayback: {
            ...get().timelinePlayback,
            sequenceId,
            position: 0,
            startTime: null,
            active: false,
          }
        });
      },

      deleteTimelineSequence: (sequenceId) => {
        set(state => {
          const timelineSequences = state.timelineSequences.filter(s => s.id !== sequenceId);
          const activeTimelineSequence = state.activeTimelineSequence === sequenceId 
            ? null 
            : state.activeTimelineSequence;

          if (state.timelinePlayback.sequenceId === sequenceId) {
            get().stopTimelinePlayback(); // Stop playback if deleting active sequence
          }

          return {
            timelineSequences,
            activeTimelineSequence,
          };
        });
      },

      updateTimelineSequence: (sequenceId, updates) => {
        set(state => ({
          timelineSequences: state.timelineSequences.map(sequence => 
            sequence.id === sequenceId 
              ? { ...sequence, ...updates, modifiedAt: Date.now() }
              : sequence
          )
        }));
      },

      exportTimelineSequence: async (sequenceId) => {
        const sequences = get().timelineSequences;
        const sequence = sequences.find(s => s.id === sequenceId);
        if (!sequence) return;

        const blob = new Blob([JSON.stringify(sequence, null, 2)], { type: 'application/json' });
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${sequence.name.replace(/\s+/g, '_')}-timeline.json`;
        document.body.appendChild(a);
        a.click();
        window.URL.revokeObjectURL(url);
        document.body.removeChild(a);
      },

      importTimelineSequence: async (file) => {
        try {
          const text = await file.text();
          const sequence: TimelineSequence = JSON.parse(text);
          
          // Generate new ID to avoid conflicts
          const newSequence = {
            ...sequence,
            id: crypto.randomUUID(),
            modifiedAt: Date.now(),
            createdAt: Date.now(),
          };

          set(state => ({
            timelineSequences: [...state.timelineSequences, newSequence]
          }));

        } catch (error) {
          console.error('Failed to import timeline sequence:', error);
        }
      },

      smoothTimelineSequence: (sequenceId, smoothingFactor = 0.5) => {
        set(state => {
          const sequence = state.timelineSequences.find(s => s.id === sequenceId);
          if (!sequence) return state;

          const smoothedChannels = sequence.channels.map(channel => ({
            ...channel,
            keyframes: channel.keyframes.map((kf, i, arr) => {
              // Skip first and last keyframes
              if (i === 0 || i === arr.length - 1) return kf;

              const prev = arr[i - 1];
              const next = arr[i + 1];

              // Calculate weighted average for value
              const smoothedValue = (
                prev.value * smoothingFactor +
                kf.value * (1 - smoothingFactor * 2) +
                next.value * smoothingFactor
              );

              return { ...kf, value: smoothedValue };
            })
          }));

          return {
            timelineSequences: state.timelineSequences.map(s =>
              s.id === sequenceId
                ? { ...s, channels: smoothedChannels, modifiedAt: Date.now() }
                : s
            )
          };
        });
      },

      playTimelineSequence: (sequenceId) => {
        const sequence = get().timelineSequences.find(s => s.id === sequenceId);
        if (!sequence) return;

        set({
          timelinePlayback: {
            active: true,
            sequenceId,
            startTime: Date.now(),
            position: 0,
            loop: get().timelinePlayback.loop,
          }
        });

        // Start playback loop
        const playbackLoop = () => {
          const state = get();
          if (!state.timelinePlayback.active) return;

          const currentTime = Date.now();
          const elapsedTime = currentTime - (state.timelinePlayback.startTime || currentTime);
          const newPosition = (elapsedTime % sequence.duration) / sequence.duration;

          // Update DMX values based on timeline position
          sequence.channels.forEach(channel => {
            const value = interpolateChannelValue(channel.keyframes, newPosition * sequence.duration);
            if (value !== undefined) {
              get().setDmxChannelValue(channel.channel, value);
            }
          });

          // Update position
          set(state => ({
            timelinePlayback: {
              ...state.timelinePlayback,
              position: newPosition,
            }
          }));

          // Request next frame if still active
          if (get().timelinePlayback.active) {
            requestAnimationFrame(playbackLoop);
          }
        };

        requestAnimationFrame(playbackLoop);
      },

      stopTimelinePlayback: () => {
        set({
          timelinePlayback: {
            ...get().timelinePlayback,
            active: false,
            position: 0,
            startTime: null,
          }
        });
      },

      generateTimelinePresets: () => {
        const commonPresets: TimelinePreset[] = [
          {
            id: 'sine',
            name: 'Sine Wave',
            description: 'Smooth oscillating motion',
            generator: (duration, amplitude = 127.5, frequency = 1, phase = 0) => {
              const steps = Math.max(10, Math.floor(duration / 100));
              const keyframes: TimelineKeyframe[] = [];

              for (let i = 0; i <= steps; i++) {
                const time = (i / steps) * duration;
                const value = 127.5 + amplitude * Math.sin(2 * Math.PI * frequency * (time / duration) + phase);
                keyframes.push({
                  time,
                  value: Math.max(0, Math.min(255, value)),
                  curve: 'smooth'
                });
              }

              return keyframes;
            }
          },
          {
            id: 'triangle',
            name: 'Triangle Wave',
            description: 'Linear ramping motion',
            generator: (duration, amplitude = 127.5, frequency = 1) => {
              const steps = Math.max(10, Math.floor(duration / 100));
              const keyframes: TimelineKeyframe[] = [];

              for (let i = 0; i <= steps; i++) {
                const time = (i / steps) * duration;
                const phase = (time / duration) * frequency;
                const triangleValue = 2 * amplitude * Math.abs((phase % 1) - 0.5);
                keyframes.push({
                  time,
                  value: Math.max(0, Math.min(255, 127.5 + triangleValue - amplitude)),
                  curve: 'linear'
                });
              }

              return keyframes;
            }
          },
          {
            id: 'square',
            name: 'Square Wave',
            description: 'On/off switching motion',
            generator: (duration, amplitude = 127.5, frequency = 1) => {
              const steps = frequency * 2; // Two points per cycle (high and low)
              const keyframes: TimelineKeyframe[] = [];
              
              for (let i = 0; i <= steps; i++) {
                const time = (i / steps) * duration;
                const value = i % 2 === 0 ? 127.5 + amplitude : 127.5 - amplitude;
                keyframes.push({
                  time,
                  value: Math.max(0, Math.min(255, value)),
                  curve: 'step'
                });
              }

              return keyframes;
            }
          }
        ];

        set({ timelinePresets: commonPresets });
      },

      createTimelineFromPreset: (presetId, name, channels, config) => {
        const preset = get().timelinePresets.find(p => p.id === presetId);
        if (!preset) return null;

        const sequence: TimelineSequence = {
          id: crypto.randomUUID(),
          name,
          duration: config.duration,
          channels: channels.map(channel => ({
            channel,
            keyframes: preset.generator(
              config.duration,
              config.amplitude,
              config.frequency,
              config.phase
            )
          })),
          createdAt: Date.now(),
          modifiedAt: Date.now()
        };

        set(state => ({
          timelineSequences: [...state.timelineSequences, sequence]
        }));

        return sequence.id;
      },
      loadTimelineSequence: (sequenceId) => {
        const timelineSequences = get().timelineSequences;
        const sequence = timelineSequences.find(s => s.id === sequenceId);
        if (!sequence) {
          console.warn(`Timeline sequence ${sequenceId} not found`);
          return;
        }

        set({
          activeTimelineSequence: sequenceId,
          timelinePlayback: {
            ...get().timelinePlayback,
            sequenceId,
            position: 0,
            startTime: null,
            active: false,
          }
        });
      },

      deleteTimelineSequence: (sequenceId) => {
        set(state => {
          const timelineSequences = state.timelineSequences.filter(s => s.id !== sequenceId);
          const activeTimelineSequence = state.activeTimelineSequence === sequenceId 
            ? null 
            : state.activeTimelineSequence;

          if (state.timelinePlayback.sequenceId === sequenceId) {
            get().stopTimelinePlayback(); // Stop playback if deleting active sequence
          }

          return {
            timelineSequences,
            activeTimelineSequence,
          };
        });
      },

      updateTimelineSequence: (sequenceId, updates) => {
        set(state => ({
          timelineSequences: state.timelineSequences.map(sequence => 
            sequence.id === sequenceId 
              ? { ...sequence, ...updates, modifiedAt: Date.now() }
              : sequence
          )
        }));
      },

      exportTimelineSequence: async (sequenceId) => {
        const sequences = get().timelineSequences;
        const sequence = sequences.find(s => s.id === sequenceId);
        if (!sequence) return;

        const blob = new Blob([JSON.stringify(sequence, null, 2)], { type: 'application/json' });
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${sequence.name.replace(/\s+/g, '_')}-timeline.json`;
        document.body.appendChild(a);
        a.click();
        window.URL.revokeObjectURL(url);
        document.body.removeChild(a);
      },

      importTimelineSequence: async (file) => {
        try {
          const text = await file.text();
          const sequence: TimelineSequence = JSON.parse(text);
          
          // Generate new ID to avoid conflicts
          const newSequence = {
            ...sequence,
            id: crypto.randomUUID(),
            modifiedAt: Date.now(),
            createdAt: Date.now(),
          };

          set(state => ({
            timelineSequences: [...state.timelineSequences, newSequence]
          }));

        } catch (error) {
          console.error('Failed to import timeline sequence:', error);
        }
      },

      smoothTimelineSequence: (sequenceId, smoothingFactor = 0.5) => {
        set(state => {
          const sequence = state.timelineSequences.find(s => s.id === sequenceId);
          if (!sequence) return state;

          const smoothedChannels = sequence.channels.map(channel => ({
            ...channel,
            keyframes: channel.keyframes.map((kf, i, arr) => {
              // Skip first and last keyframes
              if (i === 0 || i === arr.length - 1) return kf;

              const prev = arr[i - 1];
              const next = arr[i + 1];

              // Calculate weighted average for value
              const smoothedValue = (
                prev.value * smoothingFactor +
                kf.value * (1 - smoothingFactor * 2) +
                next.value * smoothingFactor
              );

              return { ...kf, value: smoothedValue };
            })
          }));

          return {
            timelineSequences: state.timelineSequences.map(s =>
              s.id === sequenceId
                ? { ...s, channels: smoothedChannels, modifiedAt: Date.now() }
                : s
            )
          };
        });
      },

      playTimelineSequence: (sequenceId) => {
        const sequence = get().timelineSequences.find(s => s.id === sequenceId);
        if (!sequence) return;

        set({
          timelinePlayback: {
            active: true,
            sequenceId,
            startTime: Date.now(),
            position: 0,
            loop: get().timelinePlayback.loop,
          }
        });

        // Start playback loop
        const playbackLoop = () => {
          const state = get();
          if (!state.timelinePlayback.active) return;

          const currentTime = Date.now();
          const elapsedTime = currentTime - (state.timelinePlayback.startTime || currentTime);
          const newPosition = (elapsedTime % sequence.duration) / sequence.duration;

          // Update DMX values based on timeline position
          sequence.channels.forEach(channel => {
            const value = interpolateChannelValue(channel.keyframes, newPosition * sequence.duration);
            if (value !== undefined) {
              get().setDmxChannelValue(channel.channel, value);
            }
          });

          // Update position
          set(state => ({
            timelinePlayback: {
              ...state.timelinePlayback,
              position: newPosition,
            }
          }));

          // Request next frame if still active
          if (get().timelinePlayback.active) {
            requestAnimationFrame(playbackLoop);
          }
        };

        requestAnimationFrame(playbackLoop);
      },

      stopTimelinePlayback: () => {
        set({
          timelinePlayback: {
            ...get().timelinePlayback,
            active: false,
            position: 0,
            startTime: null,
          }
        });
      },

      generateTimelinePresets: () => {
        const commonPresets: TimelinePreset[] = [
          {
            id: 'sine',
            name: 'Sine Wave',
            description: 'Smooth oscillating motion',
            generator: (duration, amplitude = 127.5, frequency = 1, phase = 0) => {
              const steps = Math.max(10, Math.floor(duration / 100)); // At least 10 keyframes
              const keyframes: TimelineKeyframe[] = [];

              for (let i = 0; i <= steps; i++) {
                const time = (i / steps) * duration;
                const value = 127.5 + amplitude * Math.sin(2 * Math.PI * frequency * (time / duration) + phase);
                keyframes.push({
                  time,
                  value: Math.max(0, Math.min(255, value)),
                  curve: 'smooth'
                });
              }

              return keyframes;
            }
          },
          {
            id: 'triangle',
            name: 'Triangle Wave',
            description: 'Linear ramping motion',
            generator: (duration, amplitude = 127.5, frequency = 1) => {
              const steps = Math.max(10, Math.floor(duration / 100));
              const keyframes: TimelineKeyframe[] = [];

              for (let i = 0; i <= steps; i++) {
                const time = (i / steps) * duration;
                const phase = (time / duration) * frequency;
                const triangleValue = 2 * amplitude * Math.abs((phase % 1) - 0.5);
                keyframes.push({
                  time,
                  value: Math.max(0, Math.min(255, 127.5 + triangleValue - amplitude)),
                  curve: 'linear'
                });
              }

              return keyframes;
            }
          },
          {
            id: 'square',
            name: 'Square Wave',
            description: 'On/off switching motion',
            generator: (duration, amplitude = 127.5, frequency = 1) => {
              const steps = frequency * 2; // Two points per cycle (high and low)
              const keyframes: TimelineKeyframe[] = [];
              
              for (let i = 0; i <= steps; i++) {
                const time = (i / steps) * duration;
                const value = i % 2 === 0 ? 127.5 + amplitude : 127.5 - amplitude;
                keyframes.push({
                  time,
                  value: Math.max(0, Math.min(255, value)),
                  curve: 'step'
                });
              }

              return keyframes;
            }
          }
        ];

        set({ timelinePresets: commonPresets });
      },

      createTimelineFromPreset: (presetId, name, channels, config) => {
        const preset = get().timelinePresets.find(p => p.id === presetId);
        if (!preset) return null;

        const sequence: TimelineSequence = {
          id: crypto.randomUUID(),
          name,
          duration: config.duration,
          channels: channels.map(channel => ({
            channel,
            keyframes: preset.generator(
              config.duration,
              config.amplitude,
              config.frequency,
              config.phase
            )
          })),
          createdAt: Date.now(),
          modifiedAt: Date.now()
        };

        set(state => ({
          timelineSequences: [...state.timelineSequences, sequence]
        }));

        return sequence.id;
      },

      // ... other actions ...
    }))
  )
);
    });
  },

  deleteTimelineSequence: (sequenceId: string) => {
    set(state => {
      const timelineSequences = state.timelineSequences.filter(s => s.id !== sequenceId);
      const activeTimelineSequence = state.activeTimelineSequence === sequenceId 
        ? null 
        : state.activeTimelineSequence;

      if (state.timelinePlayback.sequenceId === sequenceId) {
        get().stopTimelinePlayback(); // Stop playback if deleting active sequence
      }

      return {
        timelineSequences,
        activeTimelineSequence,
      };
    });
  },

  updateTimelineSequence: (sequenceId: string, updates: Partial<TimelineSequence>) => {
    set(state => ({
      timelineSequences: state.timelineSequences.map(sequence => 
        sequence.id === sequenceId 
          ? { ...sequence, ...updates, modifiedAt: Date.now() }
          : sequence
      )
    }));
  },

  exportTimelineSequence: async (sequenceId: string) => {
    const sequences = get().timelineSequences;
    const sequence = sequences.find(s => s.id === sequenceId);
    if (!sequence) return;

    const blob = new Blob([JSON.stringify(sequence, null, 2)], { type: 'application/json' });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${sequence.name.replace(/\s+/g, '_')}-timeline.json`;
    document.body.appendChild(a);
    a.click();
    window.URL.revokeObjectURL(url);
    document.body.removeChild(a);
  },

  importTimelineSequence: async (file: File) => {
    try {
      const text = await file.text();
      const sequence: TimelineSequence = JSON.parse(text);
      
      // Generate new ID to avoid conflicts
      const newSequence = {
        ...sequence,
        id: crypto.randomUUID(),
        modifiedAt: Date.now(),
        createdAt: Date.now(),
      };

      set(state => ({
        timelineSequences: [...state.timelineSequences, newSequence]
      }));

    } catch (error) {
      console.error('Failed to import timeline sequence:', error);
    }
  },

  smoothTimelineSequence: (sequenceId: string, smoothingFactor = 0.5) => {
    set(state => {
      const sequence = state.timelineSequences.find(s => s.id === sequenceId);
      if (!sequence) return state;

      const smoothedChannels = sequence.channels.map(channel => ({
        ...channel,
        keyframes: channel.keyframes.map((kf, i, arr) => {
          // Skip first and last keyframes
          if (i === 0 || i === arr.length - 1) return kf;

          const prev = arr[i - 1];
          const next = arr[i + 1];

          // Calculate weighted average for value
          const smoothedValue = (
            prev.value * smoothingFactor +
            kf.value * (1 - smoothingFactor * 2) +
            next.value * smoothingFactor
          );

          return { ...kf, value: smoothedValue };
        })
      }));

      return {
        timelineSequences: state.timelineSequences.map(s =>
          s.id === sequenceId
            ? { ...s, channels: smoothedChannels, modifiedAt: Date.now() }
            : s
        )
      };
    });
  },

  playTimelineSequence: (sequenceId: string) => {
    const sequence = get().timelineSequences.find(s => s.id === sequenceId);
    if (!sequence) return;

    set({
      timelinePlayback: {
        active: true,
        sequenceId,
        startTime: Date.now(),
        position: 0,
        loop: get().timelinePlayback.loop,
      }
    });

    // Start playback loop
    const playbackLoop = () => {
      const state = get();
      if (!state.timelinePlayback.active) return;

      const currentTime = Date.now();
      const elapsedTime = currentTime - (state.timelinePlayback.startTime || currentTime);
      const newPosition = (elapsedTime % sequence.duration) / sequence.duration;

      // Update DMX values based on timeline position
      sequence.channels.forEach(channel => {
        const value = interpolateChannelValue(channel.keyframes, newPosition * sequence.duration);
        if (value !== undefined) {
          get().setDmxChannelValue(channel.channel, value);
        }
      });

      // Update position
      set(state => ({
        timelinePlayback: {
          ...state.timelinePlayback,
          position: newPosition,
        }
      }));

      // Request next frame if still active
      if (get().timelinePlayback.active) {
        requestAnimationFrame(playbackLoop);
      }
    };

    requestAnimationFrame(playbackLoop);
  },

  stopTimelinePlayback: () => {
    set({
      timelinePlayback: {
        ...get().timelinePlayback,
        active: false,
        position: 0,
        startTime: null,
      }
    });
  },

  generateTimelinePresets: () => {
    const commonPresets: TimelinePreset[] = [
      {
        id: 'sine',
        name: 'Sine Wave',
        description: 'Smooth oscillating motion',
        generator: (duration, amplitude = 127.5, frequency = 1, phase = 0) => {
          const steps = Math.max(10, Math.floor(duration / 100)); // At least 10 keyframes
          const keyframes: TimelineKeyframe[] = [];

          for (let i = 0; i <= steps; i++) {
            const time = (i / steps) * duration;
            const value = 127.5 + amplitude * Math.sin(2 * Math.PI * frequency * (time / duration) + phase);
            keyframes.push({
              time,
              value: Math.max(0, Math.min(255, value)),
              curve: 'smooth'
            });
          }

          return keyframes;
        }
      },
      {
        id: 'triangle',
        name: 'Triangle Wave',
        description: 'Linear ramping motion',
        generator: (duration, amplitude = 127.5, frequency = 1) => {
          const steps = Math.max(10, Math.floor(duration / 100));
          const keyframes: TimelineKeyframe[] = [];

          for (let i = 0; i <= steps; i++) {
            const time = (i / steps) * duration;
            const phase = (time / duration) * frequency;
            const triangleValue = 2 * amplitude * Math.abs((phase % 1) - 0.5);
            keyframes.push({
              time,
              value: Math.max(0, Math.min(255, 127.5 + triangleValue - amplitude)),
              curve: 'linear'
            });
          }

          return keyframes;
        }
      },
      {
        id: 'square',
        name: 'Square Wave',
        description: 'On/off switching motion',
        generator: (duration, amplitude = 127.5, frequency = 1) => {
          const steps = frequency * 2; // Two points per cycle (high and low)
          const keyframes: TimelineKeyframe[] = [];
          
          for (let i = 0; i <= steps; i++) {
            const time = (i / steps) * duration;
            const value = i % 2 === 0 ? 127.5 + amplitude : 127.5 - amplitude;
            keyframes.push({
              time,
              value: Math.max(0, Math.min(255, value)),
              curve: 'step'
            });
          }

          return keyframes;
        }
      }
    ];

    set({ timelinePresets: commonPresets });
  },

  createTimelineFromPreset: (presetId: string, name: string, channels: number[], config: {
    duration: number;
    amplitude?: number;
    frequency?: number;
    phase?: number;
  }) => {
    const preset = get().timelinePresets.find(p => p.id === presetId);
    if (!preset) return null;

    const sequence: TimelineSequence = {
      id: crypto.randomUUID(),
      name,
      duration: config.duration,
      channels: channels.map(channel => ({
        channel,
        keyframes: preset.generator(
          config.duration,
          config.amplitude,
          config.frequency,
          config.phase
        )
      })),
      createdAt: Date.now(),
      modifiedAt: Date.now()
    };

    set(state => ({
      timelineSequences: [...state.timelineSequences, sequence]
    }));

    return sequence.id;
  },

  // ... other actions ...
  }))
);

// Helper function for timeline value interpolation
function interpolateChannelValue(keyframes: TimelineKeyframe[], time: number): number | undefined {
  if (keyframes.length === 0) return undefined;
  if (keyframes.length === 1) return keyframes[0].value;

  // Find the keyframes before and after the current time
  let prevFrame = keyframes[0];
  let nextFrame = keyframes[keyframes.length - 1];

  for (let i = 0; i < keyframes.length - 1; i++) {
    if (keyframes[i].time <= time && keyframes[i + 1].time > time) {
      prevFrame = keyframes[i];
      nextFrame = keyframes[i + 1];
      break;
    }
  }

  if (prevFrame === nextFrame) {
    return prevFrame.value;
  }

  const progress = (time - prevFrame.time) / (nextFrame.time - prevFrame.time);

  switch (prevFrame.curve) {
    case 'step':
      return prevFrame.value;
    
    case 'linear':
      return prevFrame.value + (nextFrame.value - prevFrame.value) * progress;
    
    case 'smooth':
      // Use smoothstep interpolation
      const t = progress * progress * (3 - 2 * progress);
      return prevFrame.value + (nextFrame.value - prevFrame.value) * t;
    
    case 'ease-in':
      const ti = progress * progress;
      return prevFrame.value + (nextFrame.value - prevFrame.value) * ti;
    
    case 'ease-out':
      const to = 1 - Math.pow(1 - progress, 2);
      return prevFrame.value + (nextFrame.value - prevFrame.value) * to;
    
    case 'ease-in-out':
      const tio = progress < 0.5
        ? 2 * progress * progress
        : 1 - Math.pow(-2 * progress + 2, 2) / 2;
      return prevFrame.value + (nextFrame.value - prevFrame.value) * tio;
    
    case 'bezier':
      if (prevFrame.controlPoint1 && prevFrame.controlPoint2) {
        // Cubic Bezier interpolation
        const t = progress;
        const u = 1 - t;
        const tt = t * t;
        const uu = u * u;
        const uuu = uu * u;
        const ttt = tt * t;
        
        const p0 = prevFrame.value;
        const p1 = prevFrame.controlPoint1.y;
        const p2 = prevFrame.controlPoint2.y;
        const p3 = nextFrame.value;
        
        return uuu * p0 + 3 * uu * t * p1 + 3 * u * tt * p2 + ttt * p3;
      }
      return prevFrame.value + (nextFrame.value - prevFrame.value) * progress;
    
    default:
      return prevFrame.value + (nextFrame.value - prevFrame.value) * progress;
  }
}